# 多态

## 多态的理解

多态（Polymorphism）是面向对象编程的三大特性之一（封装、继承、多态），指的是**同一个行为具有多个不同表现形式或形态的能力**。

多态的核心思想是：

- **允许父类引用指向子类对象**
- **同一个接口，使用不同的实例执行不同的操作**
- 提高了代码的可扩展性和可维护性

## 多态的分类

### 1. 编译时多态（静态多态）

- 通过**方法重载**实现
- 在编译时就能确定调用哪个方法
- 根据参数列表的不同来区分

### 2. 运行时多态（动态多态）

- 通过**方法重写**和**继承**实现
- 在运行时根据实际对象类型确定调用哪个方法
- 需要满足三个条件：继承、重写、向上转型

## 多态Demo

```java
// 父类
class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // 将被重写的方法
    public void makeSound() {
        System.out.println("动物发出声音");
    }
    
    public String getName() {
        return name;
    }
}

// 子类1
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    // 重写父类方法
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 汪汪汪!");
    }
    
    // 狗特有的方法
    public void wagTail() {
        System.out.println(getName() + "在摇尾巴");
    }
}

// 子类2
class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    // 重写父类方法
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 喵喵喵!");
    }
    
    // 猫特有的方法
    public void climbTree() {
        System.out.println(getName() + "在爬树");
    }
}

// 子类3
class Bird extends Animal {
    public Bird(String name) {
        super(name);
    }
    
    // 重写父类方法
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 叽叽喳喳!");
    }
    
    // 不重写makeSound方法，将使用父类的实现
}

// 演示多态的主类
public class PolymorphismDemo {
    public static void main(String[] args) {
        // 多态的体现：父类引用指向子类对象
        Animal myDog = new Dog("小黑");
        Animal myCat = new Cat("小白");
        Animal myBird = new Bird("小黄");
        
        // 运行时多态：同一个方法调用，不同的行为
        System.out.println("=== 动物叫声演示 ===");
        makeAnimalSound(myDog);    // 输出: 小黑: 汪汪汪!
        makeAnimalSound(myCat);    // 输出: 小白: 喵喵喵!
        makeAnimalSound(myBird);   // 输出: 小黄: 叽叽喳喳!
        
        System.out.println("\n=== 动物数组演示 ===");
        Animal[] animals = {
            new Dog("旺财"),
            new Cat("咪咪"),
            new Bird("啾啾"),
            new Dog("来福")
        };
        
        for (Animal animal : animals) {
            animal.makeSound(); // 多态调用
        }
        
        System.out.println("\n=== 类型检查和转换演示 ===");
        // 类型检查和转换
        checkAndCastAnimal(myDog);
        checkAndCastAnimal(myCat);
    }
    
    // 多态方法的参数：可以接受任何Animal子类对象
    public static void makeAnimalSound(Animal animal) {
        animal.makeSound(); // 运行时根据实际对象类型决定调用哪个方法
    }
    
    // 类型检查和转换
    public static void checkAndCastAnimal(Animal animal) {
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal; // 向下转型
            dog.wagTail();
        } else if (animal instanceof Cat) {
            Cat cat = (Cat) animal; // 向下转型
            cat.climbTree();
        } else {
            System.out.println(animal.getName() + "是其他动物");
        }
    }
}
```

## 方法重载Demo（编译时多态）

```java
class MathOperations {
    // 方法重载：编译时多态
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
}

public class OverloadingDemo {
    public static void main(String[] args) {
        MathOperations math = new MathOperations();
        
        // 编译时确定调用哪个方法
        System.out.println("整数相加: " + math.add(5, 3));          // 调用add(int, int)
        System.out.println("浮点数相加: " + math.add(5.5, 3.2));    // 调用add(double, double)
        System.out.println("三数相加: " + math.add(1, 2, 3));       // 调用add(int, int, int)
        System.out.println("字符串连接: " + math.add("Hello", " World")); // 调用add(String, String)
    }
}
```

## 多态的优势

1. **提高代码扩展性**：新增子类不需要修改现有代码
2. **提高代码可维护性**：减少重复代码，提高代码复用性
3. **接口统一**：可以使用父类类型处理各种子类对象
