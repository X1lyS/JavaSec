# 反射

## 理解反射

Java反射机制允许程序在运行时动态地获取类的信息并操作类的属性、方法和构造函数。反射打破了Java的封装性，但提供了极大的灵活性。

**核心价值**：

- 运行时动态获取类信息
- 动态创建对象和调用方法
- 实现通用框架和工具
- 突破访问限制

## 获取Class对象

获取Class对象的三种方式：

```java
// 1. 通过类名.class
Class<String> stringClass = String.class;

// 2. 通过对象.getClass()
String str = "Hello";
Class<?> strClass = str.getClass();

// 3. 通过Class.forName()（最常用）
try {
    Class<?> clazz = Class.forName("java.lang.String");
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
```

## 反射API

### java.lang.Class

Class类是反射的核心，代表一个类或接口。

```java
public class ClassDemo {
    public static void main(String[] args) {
        try {
            Class<?> userClass = Class.forName("com.example.User");
            
            // 获取类名
            System.out.println("类名: " + userClass.getName());
            System.out.println("简单类名: " + userClass.getSimpleName());
            
            // 获取包信息
            Package pkg = userClass.getPackage();
            System.out.println("包名: " + pkg.getName());
            
            // 获取父类
            Class<?> superClass = userClass.getSuperclass();
            System.out.println("父类: " + superClass.getName());
            
            // 获取实现的接口
            Class<?>[] interfaces = userClass.getInterfaces();
            for (Class<?> inter : interfaces) {
                System.out.println("接口: " + inter.getName());
            }
            
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.Field

Field类代表类的成员变量。

```java
import java.lang.reflect.Field;

class User {
    private String name;
    public int age;
    protected String email;
}

public class FieldDemo {
    public static void main(String[] args) {
        try {
            Class<?> userClass = Class.forName("User");
            
            // 获取所有public字段（包括父类）
            Field[] publicFields = userClass.getFields();
            System.out.println("Public字段:");
            for (Field field : publicFields) {
                System.out.println(field.getName());
            }
            
            // 获取所有声明的字段（不包括父类）
            Field[] declaredFields = userClass.getDeclaredFields();
            System.out.println("所有声明字段:");
            for (Field field : declaredFields) {
                System.out.println(field.getName() + " - " + field.getType());
            }
            
            // 访问和修改字段值
            User user = new User();
            Field ageField = userClass.getField("age");
            ageField.set(user, 25);
            System.out.println("设置后的年龄: " + ageField.get(user));
            
            // 访问私有字段（需要设置可访问）
            Field nameField = userClass.getDeclaredField("name");
            nameField.setAccessible(true); // 突破访问限制
            nameField.set(user, "张三");
            System.out.println("设置后的姓名: " + nameField.get(user));
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.Method

Method类代表类的方法。

```java
import java.lang.reflect.Method;

class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    private String greet(String name) {
        return "Hello, " + name;
    }
    
    public static void staticMethod() {
        System.out.println("静态方法被调用");
    }
}

public class MethodDemo {
    public static void main(String[] args) {
        try {
            Class<?> calcClass = Class.forName("Calculator");
            Calculator calculator = (Calculator) calcClass.newInstance();
            
            // 获取public方法（包括父类）
            Method[] publicMethods = calcClass.getMethods();
            System.out.println("Public方法:");
            for (Method method : publicMethods) {
                System.out.println(method.getName());
            }
            
            // 获取特定方法
            Method addMethod = calcClass.getMethod("add", int.class, int.class);
            Object result = addMethod.invoke(calculator, 10, 20);
            System.out.println("加法结果: " + result);
            
            // 调用私有方法
            Method greetMethod = calcClass.getDeclaredMethod("greet", String.class);
            greetMethod.setAccessible(true);
            Object greeting = greetMethod.invoke(calculator, "反射");
            System.out.println("问候: " + greeting);
            
            // 调用静态方法
            Method staticMethod = calcClass.getMethod("staticMethod");
            staticMethod.invoke(null);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.Modifier

Modifier类用于解析修饰符。

```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class ModifierDemo {
    public static void main(String[] args) {
        try {
            Class<?> userClass = Class.forName("User");
            
            // 解析类的修饰符
            int classModifiers = userClass.getModifiers();
            System.out.println("类修饰符: " + Modifier.toString(classModifiers));
            System.out.println("是public类: " + Modifier.isPublic(classModifiers));
            
            // 解析字段修饰符
            Field[] fields = userClass.getDeclaredFields();
            for (Field field : fields) {
                int fieldModifiers = field.getModifiers();
                System.out.println(field.getName() + " 修饰符: " + 
                                  Modifier.toString(fieldModifiers));
            }
            
            // 解析方法修饰符
            Method[] methods = userClass.getDeclaredMethods();
            for (Method method : methods) {
                int methodModifiers = method.getModifiers();
                System.out.println(method.getName() + " 修饰符: " + 
                                  Modifier.toString(methodModifiers));
            }
            
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.Constructor

Constructor类代表类的构造函数。

```java
import java.lang.reflect.Constructor;

class Person {
    private String name;
    private int age;
    
    public Person() {}
    
    public Person(String name) {
        this.name = name;
    }
    
    private Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class ConstructorDemo {
    public static void main(String[] args) {
        try {
            Class<?> personClass = Class.forName("Person");
            
            // 获取所有public构造函数
            Constructor<?>[] publicConstructors = personClass.getConstructors();
            System.out.println("Public构造函数:");
            for (Constructor<?> constructor : publicConstructors) {
                System.out.println(constructor);
            }
            
            // 获取所有声明的构造函数
            Constructor<?>[] declaredConstructors = personClass.getDeclaredConstructors();
            System.out.println("所有声明构造函数:");
            for (Constructor<?> constructor : declaredConstructors) {
                System.out.println(constructor);
            }
            
            // 使用无参构造函数创建对象
            Constructor<?> noArgConstructor = personClass.getConstructor();
            Person person1 = (Person) noArgConstructor.newInstance();
            System.out.println("无参构造创建对象: " + person1);
            
            // 使用有参构造函数创建对象
            Constructor<?> stringConstructor = personClass.getConstructor(String.class);
            Person person2 = (Person) stringConstructor.newInstance("李四");
            System.out.println("有参构造创建对象: " + person2);
            
            // 使用私有构造函数创建对象
            Constructor<?> privateConstructor = personClass.getDeclaredConstructor(
                String.class, int.class);
            privateConstructor.setAccessible(true);
            Person person3 = (Person) privateConstructor.newInstance("王五", 30);
            System.out.println("私有构造创建对象: " + person3);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.Parameter

Parameter类用于获取方法参数信息（需要编译时加上-parameters参数）。

```java
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

class TestClass {
    public void testMethod(String name, int age, double salary) {
        // 方法实现
    }
}

public class ParameterDemo {
    public static void main(String[] args) {
        try {
            Class<?> testClass = Class.forName("TestClass");
            Method method = testClass.getMethod("testMethod", 
                String.class, int.class, double.class);
            
            // 获取参数信息
            Parameter[] parameters = method.getParameters();
            for (Parameter param : parameters) {
                System.out.println("参数名: " + param.getName());
                System.out.println("参数类型: " + param.getType());
                System.out.println("是否是名称存在: " + param.isNamePresent());
                System.out.println("---");
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### java.lang.reflect.AccessibleObject

AccessibleObject是Field、Method、Constructor的父类，用于控制访问权限。

```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;

class SecureClass {
    private String secret = " confidential";
    private void secretMethod() {
        System.out.println("秘密方法被调用");
    }
}

public class AccessibleObjectDemo {
    public static void main(String[] args) {
        try {
            Class<?> secureClass = Class.forName("SecureClass");
            SecureClass instance = (SecureClass) secureClass.newInstance();
            
            // 访问私有字段
            Field secretField = secureClass.getDeclaredField("secret");
            System.out.println("默认可访问: " + secretField.isAccessible());
            
            // 设置可访问并读取值
            secretField.setAccessible(true);
            String secretValue = (String) secretField.get(instance);
            System.out.println("秘密值: " + secretValue);
            
            // 访问私有方法
            Method secretMethod = secureClass.getDeclaredMethod("secretMethod");
            secretMethod.setAccessible(true);
            secretMethod.invoke(instance);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 反射到命令执行

### 通过getMethod调用Runtime.exec()

```java
import java.lang.reflect.Method;

public class RuntimeReflection {
    public static void main(String[] args) {
        try {
            // 获取Runtime类
            Class<?> runtimeClass = Class.forName("java.lang.Runtime");
            
            // 获取getRuntime方法
            Method getRuntimeMethod = runtimeClass.getMethod("getRuntime");
            
            // 调用getRuntime方法获取Runtime实例
            Object runtimeInstance = getRuntimeMethod.invoke(null);
            
            // 获取exec方法
            Method execMethod = runtimeClass.getMethod("exec", String.class);
            
            // 执行命令（Windows和Linux命令不同）
            String command = "calc.exe"; // Windows计算器
            // String command = "gnome-calculator"; // Linux计算器
            
            Process process = (Process) execMethod.invoke(runtimeInstance, command);
            System.out.println("进程已启动: " + process);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 通过getDeclaredConstructor调用Runtime

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class RuntimeConstructorReflection {
    public static void main(String[] args) {
        try {
            // 获取Runtime类
            Class<?> runtimeClass = Class.forName("java.lang.Runtime");
            
            // 获取私有构造函数
            Constructor<?> runtimeConstructor = runtimeClass.getDeclaredConstructor();
            
            // 设置可访问
            runtimeConstructor.setAccessible(true);
            
            // 创建Runtime实例
            Object runtimeInstance = runtimeConstructor.newInstance();
            
            // 获取exec方法
            Method execMethod = runtimeClass.getMethod("exec", String.class);
            
            // 执行命令
            String command = "notepad.exe"; // Windows记事本
            Process process = (Process) execMethod.invoke(runtimeInstance, command);
            System.out.println("进程已启动: " + process);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 使用ProcessBuilder执行命令

```java
import java.lang.reflect.Method;
import java.util.Arrays;

public class ProcessBuilderReflection {
    public static void main(String[] args) {
        try {
            // 获取ProcessBuilder类
            Class<?> pbClass = Class.forName("java.lang.ProcessBuilder");
            
            // 获取构造函数（接受String列表）
            Constructor<?> pbConstructor = pbClass.getConstructor(List.class);
            
            // 创建命令列表
            List<String> command = Arrays.asList("cmd.exe", "/c", "echo Hello Reflection");
            
            // 创建ProcessBuilder实例
            Object processBuilder = pbConstructor.newInstance(command);
            
            // 获取start方法
            Method startMethod = pbClass.getMethod("start");
            
            // 启动进程
            Process process = (Process) startMethod.invoke(processBuilder);
            
            // 等待进程完成
            process.waitFor();
            System.out.println("命令执行完成，退出码: " + process.exitValue());
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

