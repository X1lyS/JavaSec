# 命令执行操作

在Java安全代码审计中，命令执行是高风险操作点。提供三种常见的命令执行方式的Demo，并分析其安全风险。

## Runtime.exec() 

```java
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

public class RuntimeExecDemo {
    
    // 不安全的执行方式
    public static void unsafeExec(String cmd) {
        try {
            // 直接执行用户输入的命令
            Process process = Runtime.getRuntime().exec(cmd);
            printProcessOutput(process);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // 相对安全的执行方式
    public static void safeExec(String[] cmdArray) {
        try {
            // 使用字符串数组方式执行，避免shell解释
            Process process = Runtime.getRuntime().exec(cmdArray);
            printProcessOutput(process);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private static void printProcessOutput(Process process) throws Exception {
        InputStream inputStream = process.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
        reader.close();
    }

    public static void main(String[] args) {
        // 不安全示例
        System.out.println("=== 不安全执行 ===");
        unsafeExec("ls -la /tmp; echo '恶意命令'");
        
        // 安全示例
        System.out.println("\n=== 安全执行 ===");
        safeExec(new String[]{"ls", "-la", "/tmp"});
    }
}
```

1. `unsafeExec`方法直接执行字符串命令，如果用户输入包含`;`、`&&`、`|`等符号，可能执行额外命令
2. `safeExec`方法使用字符串数组，避免shell解释器处理特殊字符

## ProcessBuilder 

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;

public class ProcessBuilderDemo {
    
    // 不安全的执行方式
    public static void unsafeBuild(String cmd) {
        try {
            // 直接使用字符串构造ProcessBuilder
            ProcessBuilder builder = new ProcessBuilder(cmd);
            builder.redirectErrorStream(true);
            Process process = builder.start();
            printProcessOutput(process);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // 安全的执行方式
    public static void safeBuild(String[] cmdArray) {
        try {
            // 使用字符串数组构造ProcessBuilder
            ProcessBuilder builder = new ProcessBuilder(cmdArray);
            
            // 设置工作目录（限制执行环境）
            builder.directory(new File("/safe/directory"));
            
            // 合并错误流和输出流
            builder.redirectErrorStream(true);
            
            // 设置环境变量（可选）
            Map<String, String> env = builder.environment();
            env.put("PATH", "/usr/local/bin:/usr/bin:/bin");
            
            Process process = builder.start();
            printProcessOutput(process);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private static void printProcessOutput(Process process) throws Exception {
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
        reader.close();
    }

    public static void main(String[] args) {
        // 不安全示例
        System.out.println("=== 不安全构建 ===");
        unsafeBuild("cat /etc/passwd | grep root");
        
        // 安全示例
        System.out.println("\n=== 安全构建 ===");
        safeBuild(new String[]{"ls", "-la"});
    }
}
```

1. `unsafeBuild`方法直接使用字符串构造命令，存在命令注入风险
2. `safeBuild`方法通过字符串数组构造命令，并限制执行环境和工作目录

## UNIXProcess/ProcessImpl 

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class UnixProcessDemo {
    
    // 不安全的反射调用方式（仅用于演示）
    public static void unsafeReflectExec() {
        try {
            // 反射调用UNIXProcess/ProcessImpl（JDK内部类）
            Class<?> clazz = Class.forName("java.lang.UNIXProcess");
            Constructor<?> constructor = clazz.getDeclaredConstructor(
                byte[].class, byte[].class, int.class, File.class, 
                byte[].class, int[].class, boolean.class);
            constructor.setAccessible(true);
            
            // 构造命令参数
            byte[] command = "/bin/bash -c 'echo 危险操作'".getBytes();
            byte[] env = new byte[0];
            byte[] dir = "/".getBytes();
            
            Object process = constructor.newInstance(
                command, env, command.length, null, dir, new int[]{-1, -1, -1}, false);
            
            Method waitFor = clazz.getMethod("waitFor");
            waitFor.invoke(process);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        System.out.println("=== 不安全的反射调用 ===");
        unsafeReflectExec();
    }
}
```

1. 直接使用JDK内部类，违反Java规范
2. 绕过安全检查机制，极其危险
3. 不同JDK版本实现可能不同，兼容性差

## 安全示例：带校验的命令执行

1. **避免直接执行命令**：优先使用Java API替代系统命令
2. **使用白名单校验**：对命令和参数进行严格校验
3. **限制执行权限**：使用低权限用户执行命令
4. **日志记录**：记录执行的命令和参数
5. **超时控制**：设置命令执行超时时间

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class SecureCommandExecutor {
    
    private static final Set<String> ALLOWED_COMMANDS = new HashSet<>(
        Arrays.asList("ls", "pwd", "date"));
    
    private static final Set<String> ALLOWED_OPTIONS = new HashSet<>(
        Arrays.asList("-a", "-l", "-h"));
    
    public static void executeWithValidation(String[] cmdArray) {
        // 校验命令是否在允许列表中
        if (cmdArray == null || cmdArray.length == 0 || 
            !ALLOWED_COMMANDS.contains(cmdArray[0])) {
            throw new SecurityException("不允许的命令: " + 
                (cmdArray != null && cmdArray.length > 0 ? cmdArray[0] : "null"));
        }
        
        // 校验参数
        for (int i = 1; i < cmdArray.length; i++) {
            if (!ALLOWED_OPTIONS.contains(cmdArray[i])) {
                throw new SecurityException("不允许的参数: " + cmdArray[i]);
            }
        }
        
        try {
            ProcessBuilder builder = new ProcessBuilder(cmdArray);
            builder.redirectErrorStream(true);
            
            // 设置超时（Java 8+）
            Process process = builder.start();
            
            // 读取输出
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            
            // 等待进程结束（带超时）
            if (!process.waitFor(5, TimeUnit.SECONDS)) {
                process.destroyForcibly();
                throw new RuntimeException("命令执行超时");
            }
            
            // 检查退出码
            if (process.exitValue() != 0) {
                throw new RuntimeException("命令执行失败，退出码: " + process.exitValue());
            }
        } catch (Exception e) {
            throw new RuntimeException("命令执行错误", e);
        }
    }

    public static void main(String[] args) {
        // 合法命令
        System.out.println("=== 合法命令 ===");
        executeWithValidation(new String[]{"ls", "-l"});
        
        // 非法命令
        System.out.println("\n=== 非法命令 ===");
        try {
            executeWithValidation(new String[]{"rm", "-rf"});
        } catch (Exception e) {
            System.err.println("安全拦截: " + e.getMessage());
        }
    }
}
```

在实际安全审计中，应特别关注直接使用Runtime.exec(String)或ProcessBuilder(String)的代码，这些是命令注入的高风险点。

