# 文件上传操作

java中最常见的文件上传操作就两种：Multipartfile方式文件上传和ServletFileUpload方式文件上传

## MultipartFile方式 (Spring框架)

这是Spring框架中常用的文件上传方式，基于`MultipartFile`接口实现。

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Controller
public class MultipartFileUploadController {

    // 上传目录，实际项目中应该配置在配置文件中
    private static String UPLOADED_FOLDER = "/tmp/uploads/";

    @PostMapping("/upload")
    public String handleFileUpload(@RequestParam("file") MultipartFile file,
                                  RedirectAttributes redirectAttributes) {

        if (file.isEmpty()) {
            redirectAttributes.addFlashAttribute("message", "请选择一个文件上传");
            return "redirect:/uploadStatus";
        }

        try {
            // 获取文件字节数据
            byte[] bytes = file.getBytes();
            
            // 创建上传目录（如果不存在）
            Path uploadPath = Paths.get(UPLOADED_FOLDER);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            
            // 保存文件
            Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());
            Files.write(path, bytes);

            redirectAttributes.addFlashAttribute("message",
                    "文件上传成功: " + file.getOriginalFilename());
        } catch (IOException e) {
            e.printStackTrace();
            redirectAttributes.addFlashAttribute("message",
                    "文件上传失败: " + file.getOriginalFilename());
        }

        return "redirect:/uploadStatus";
    }
}
```

## ServletFileUpload (原生Servlet)

这是基于Apache Commons FileUpload库的原生Servlet实现方式。

```java
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.List;

@WebServlet("/uploadServlet")
public class FileUploadServlet extends HttpServlet {
    
    private static final String UPLOAD_DIRECTORY = "/tmp/uploads";
    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3;  // 3MB
    private static final int MAX_FILE_SIZE = 1024 * 1024 * 40;    // 40MB
    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        // 检查是否是文件上传请求
        if (!ServletFileUpload.isMultipartContent(request)) {
            response.getWriter().println("错误: 表单必须包含 enctype=multipart/form-data");
            return;
        }

        // 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        factory.setRepository(new File(System.getProperty("java.io.tmpdir")));

        ServletFileUpload upload = new ServletFileUpload(factory);
        upload.setFileSizeMax(MAX_FILE_SIZE);
        upload.setSizeMax(MAX_REQUEST_SIZE);

        // 创建上传目录
        File uploadDir = new File(UPLOAD_DIRECTORY);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }

        try {
            // 解析请求内容提取文件数据
            List<FileItem> formItems = upload.parseRequest(request);

            if (formItems != null && formItems.size() > 0) {
                for (FileItem item : formItems) {
                    // 处理表单字段
                    if (!item.isFormField()) {
                        String fileName = new File(item.getName()).getName();
                        String filePath = UPLOAD_DIRECTORY + File.separator + fileName;
                        File storeFile = new File(filePath);
                        
                        // 保存文件到磁盘
                        item.write(storeFile);
                        response.getWriter().println("文件上传成功: " + fileName);
                    }
                }
            }
        } catch (Exception ex) {
            response.getWriter().println("文件上传失败: " + ex.getMessage());
        }
    }
}
```

## 安全实践

### Spring MultipartFile

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.apache.commons.io.FilenameUtils;
import org.springframework.http.MediaType;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.UUID;

@Controller
public class SecureMultipartFileUpload {

    // 配置在application.properties中更安全
    private static final String UPLOAD_DIR = "/secure/upload/dir/";
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    private static final String[] ALLOWED_EXTENSIONS = {"jpg", "jpeg", "png", "gif"};
    private static final String[] ALLOWED_MIME_TYPES = {
        MediaType.IMAGE_JPEG_VALUE,
        MediaType.IMAGE_PNG_VALUE,
        "image/gif"
    };

    @PostMapping("/secureUpload")
    public String secureUpload(@RequestParam("file") MultipartFile file) {
        
        // 1. 基础校验
        if (file == null || file.isEmpty()) {
            throw new RuntimeException("文件不能为空");
        }

        // 2. 文件大小校验
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new RuntimeException("文件大小不能超过10MB");
        }

        // 3. 获取安全的文件名
        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null || originalFilename.contains("../")) {
            throw new RuntimeException("非法文件名");
        }

        // 4. 文件扩展名校验
        String fileExtension = FilenameUtils.getExtension(originalFilename).toLowerCase();
        if (!Arrays.asList(ALLOWED_EXTENSIONS).contains(fileExtension)) {
            throw new RuntimeException("不支持的文件类型");
        }

        // 5. MIME类型校验
        String contentType = file.getContentType();
        if (!Arrays.asList(ALLOWED_MIME_TYPES).contains(contentType)) {
            throw new RuntimeException("非法的文件内容类型");
        }

        // 6. 生成随机文件名
        String safeFileName = UUID.randomUUID().toString() + "." + fileExtension;

        try {
            // 7. 创建上传目录(如果不存在)
            Path uploadPath = Paths.get(UPLOAD_DIR);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }

            // 8. 设置文件权限(仅限Linux/Unix)
            Path filePath = uploadPath.resolve(safeFileName);
            Files.copy(file.getInputStream(), filePath);
            
            // 设置文件权限为644 (rw-r--r--)
            filePath.toFile().setReadable(true, false);
            filePath.toFile().setWritable(true, true);
            filePath.toFile().setExecutable(false, false);

            return "上传成功: " + safeFileName;
        } catch (IOException e) {
            throw new RuntimeException("文件上传失败", e);
        }
    }
}
```

### ServletFileUpload

```java
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.io.FilenameUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

@WebServlet("/secureFileUpload")
public class SecureServletFileUpload extends HttpServlet {

    private static final String UPLOAD_DIR = "/secure/upload/dir/";
    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3;  // 3MB
    private static final int MAX_FILE_SIZE = 1024 * 1024 * 10;    // 10MB
    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 15; // 15MB
    private static final String[] ALLOWED_EXTENSIONS = {"jpg", "jpeg", "png", "gif"};

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // 1. 检查是否是文件上传请求
        if (!ServletFileUpload.isMultipartContent(request)) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "请求必须包含multipart/form-data");
            return;
        }

        // 2. 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        factory.setRepository(new File(System.getProperty("java.io.tmpdir")));

        ServletFileUpload upload = new ServletFileUpload(factory);
        upload.setFileSizeMax(MAX_FILE_SIZE);
        upload.setSizeMax(MAX_REQUEST_SIZE);

        // 3. 创建安全的上传目录
        File uploadDir = new File(UPLOAD_DIR);
        if (!uploadDir.exists()) {
            if (!uploadDir.mkdirs()) {
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "无法创建上传目录");
                return;
            }
            // 设置目录权限(仅限Linux/Unix)
            uploadDir.setReadable(true, false);
            uploadDir.setWritable(true, true);
            uploadDir.setExecutable(false, false);
        }

        try {
            // 4. 解析请求内容
            List<FileItem> formItems = upload.parseRequest(request);

            if (formItems != null) {
                for (FileItem item : formItems) {
                    if (!item.isFormField()) {
                        // 5. 获取原始文件名并校验
                        String fileName = FilenameUtils.getName(item.getName());
                        if (fileName == null || fileName.isEmpty()) {
                            continue;
                        }

                        // 6. 文件扩展名校验
                        String fileExtension = FilenameUtils.getExtension(fileName).toLowerCase();
                        if (!Arrays.asList(ALLOWED_EXTENSIONS).contains(fileExtension)) {
                            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "不支持的文件类型");
                            return;
                        }

                        // 7. 生成随机文件名
                        String safeFileName = UUID.randomUUID().toString() + "." + fileExtension;
                        String filePath = UPLOAD_DIR + File.separator + safeFileName;
                        File storeFile = new File(filePath);

                        // 8. 保存文件
                        item.write(storeFile);

                        // 9. 设置文件权限(仅限Linux/Unix)
                        storeFile.setReadable(true, false);
                        storeFile.setWritable(true, true);
                        storeFile.setExecutable(false, false);

                        response.getWriter().println("文件上传成功: " + safeFileName);
                    }
                }
            }
        } catch (FileUploadException e) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "文件上传失败");
        } catch (Exception e) {
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "服务器错误");
        }
    }
}
```

