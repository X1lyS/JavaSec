# 序列化和反序列化

### 什么是序列化

序列化是将对象转换为字节流的过程，以便存储或传输。反序列化则是将字节流重新转换为对象的过程。

### 实现序列化的条件

1. 类必须实现 `java.io.Serializable` 接口
2. 所有字段必须是可序列化的，基本类型都是可序列化的
3. 使用 `transient` 关键字标记不想序列化的字段
4. 建议提供 `serialVersionUID` 字段用于版本控制

### 基本序列化示例

```java
import java.io.*;

// 实现Serializable接口
class Person implements Serializable {
    // 建议提供serialVersionUID用于版本控制
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
    private transient String password; // 不会被序列化
    
    public Person(String name, int age, String password) {
        this.name = name;
        this.age = age;
        this.password = password;
    }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", password='" + password + "'}";
    }
}

public class SerializationDemo {
    public static void main(String[] args) {
        Person person = new Person("张三", 25, "secret123");
        
        // 序列化对象到文件
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
            System.out.println("对象序列化成功");
            System.out.println("原始对象: " + person);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 序列化数组和集合

```java
import java.io.*;
import java.util.*;

class SerializationCollectionDemo {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30, "pass1"),
            new Person("Bob", 25, "pass2"),
            new Person("Charlie", 35, "pass3")
        );
        
        // 序列化集合
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("people.ser"))) {
            oos.writeObject(people);
            System.out.println("集合序列化成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 序列化数组
        int[] numbers = {1, 2, 3, 4, 5};
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("numbers.ser"))) {
            oos.writeObject(numbers);
            System.out.println("数组序列化成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 自定义序列化过程

```java
import java.io.*;

class CustomSerialization implements Serializable {
    private static final long serialVersionUID = 1L;
    private String data;
    private transient String sensitiveData;
    
    public CustomSerialization(String data, String sensitiveData) {
        this.data = data;
        this.sensitiveData = sensitiveData;
    }
    
    // 自定义序列化方法
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject(); // 序列化非transient字段
        // 对敏感数据进行加密后再序列化
        String encrypted = encrypt(sensitiveData);
        oos.writeObject(encrypted);
    }
    
    // 自定义反序列化方法
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject(); // 反序列化非transient字段
        // 解密敏感数据
        String encrypted = (String) ois.readObject();
        sensitiveData = decrypt(encrypted);
    }
    
    private String encrypt(String data) {
        // 简单的加密示例（实际应用中应使用更强的加密算法）
        return new StringBuilder(data).reverse().toString();
    }
    
    private String decrypt(String data) {
        // 解密
        return new StringBuilder(data).reverse().toString();
    }
    
    @Override
    public String toString() {
        return "CustomSerialization{data='" + data + "', sensitiveData='" + sensitiveData + "'}";
    }
}

public class CustomSerializationDemo {
    public static void main(String[] args) {
        CustomSerialization obj = new CustomSerialization("普通数据", "敏感信息");
        
        // 序列化
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("custom.ser"))) {
            oos.writeObject(obj);
            System.out.println("自定义序列化完成: " + obj);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 反序列化

### 基本反序列化

```java
import java.io.*;

public class DeserializationDemo {
    public static void main(String[] args) {
        // 反序列化对象
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("person.ser"))) {
            Person person = (Person) ois.readObject();
            System.out.println("对象反序列化成功");
            System.out.println("反序列化对象: " + person);
            // 注意：password字段为null，因为被transient修饰
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        
        // 反序列化集合
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("people.ser"))) {
            @SuppressWarnings("unchecked")
            List<Person> people = (List<Person>) ois.readObject();
            System.out.println("集合反序列化成功:");
            for (Person p : people) {
                System.out.println("  " + p);
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        
        // 反序列化数组
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("numbers.ser"))) {
            int[] numbers = (int[]) ois.readObject();
            System.out.println("数组反序列化成功:");
            for (int num : numbers) {
                System.out.print(num + " ");
            }
            System.out.println();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 自定义反序列化示例

```java
import java.io.*;

public class CustomDeserializationDemo {
    public static void main(String[] args) {
        // 先序列化（如果文件不存在）
        File file = new File("custom.ser");
        if (!file.exists()) {
            CustomSerialization obj = new CustomSerialization("普通数据", "敏感信息");
            try (ObjectOutputStream oos = new ObjectOutputStream(
                    new FileOutputStream("custom.ser"))) {
                oos.writeObject(obj);
                System.out.println("已创建序列化文件");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        // 反序列化自定义对象
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("custom.ser"))) {
            CustomSerialization obj = (CustomSerialization) ois.readObject();
            System.out.println("自定义反序列化成功: " + obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 序列化版本控制

```java
import java.io.*;

class VersionedObject implements Serializable {
    // 版本1
    // private static final long serialVersionUID = 1L;
    
    // 版本2（修改后）
    private static final long serialVersionUID = 2L;
    
    private String name;
    private int age;
    // 版本2新增字段
    private String email;
    
    public VersionedObject(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public VersionedObject(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    @Override
    public String toString() {
        return "VersionedObject{name='" + name + "', age=" + age + ", email='" + email + "'}";
    }
}

public class VersionControlDemo {
    public static void main(String[] args) {
        // 序列化版本2对象
        VersionedObject obj = new VersionedObject("李四", 30, "lisi@example.com");
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("versioned.ser"))) {
            oos.writeObject(obj);
            System.out.println("版本2对象序列化成功: " + obj);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 反序列化（即使类定义发生了变化）
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("versioned.ser"))) {
            VersionedObject deserialized = (VersionedObject) ois.readObject();
            System.out.println("反序列化成功: " + deserialized);
        } catch (IOException | ClassNotFoundException e) {
            System.out.println("反序列化失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### 外部化（Externalizable）接口

```java
import java.io.*;

class ExternalizableDemo implements Externalizable {
    private String name;
    private int age;
    private transient String temporaryData;
    
    // 必须有无参构造函数
    public ExternalizableDemo() {
        System.out.println("无参构造函数被调用");
    }
    
    public ExternalizableDemo(String name, int age, String temporaryData) {
        this.name = name;
        this.age = age;
        this.temporaryData = temporaryData;
    }
    
    // 自定义写操作
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
        // temporaryData不会被自动序列化，需要手动处理
        out.writeUTF(temporaryData != null ? temporaryData : "");
    }
    
    // 自定义读操作
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = in.readUTF();
        age = in.readInt();
        temporaryData = in.readUTF();
    }
    
    @Override
    public String toString() {
        return "ExternalizableDemo{name='" + name + "', age=" + age + 
               ", temporaryData='" + temporaryData + "'}";
    }
}

public class ExternalizableExample {
    public static void main(String[] args) {
        ExternalizableDemo obj = new ExternalizableDemo("王五", 40, "临时数据");
        
        // 序列化
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("external.ser"))) {
            oos.writeObject(obj);
            System.out.println("Externalizable对象序列化成功: " + obj);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 反序列化
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("external.ser"))) {
            ExternalizableDemo deserialized = (ExternalizableDemo) ois.readObject();
            System.out.println("Externalizable对象反序列化成功: " + deserialized);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 安全注意事项

```java
import java.io.*;

public class SecurityDemo {
    public static void main(String[] args) {
        // 安全建议1：不要反序列化不可信的数据
        String untrustedData = "不可信的序列化数据";
        // 应该验证数据来源和完整性
        
        // 安全建议2：使用白名单验证反序列化的类
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("person.ser")) {
            // 重写resolveClass方法进行验证
            @Override
            protected Class<?> resolveClass(ObjectStreamClass desc)
                    throws IOException, ClassNotFoundException {
                String className = desc.getName();
                // 只允许特定的类
                if (!className.equals("Person") && !className.startsWith("java.")) {
                    throw new InvalidClassException("未经授权的类: " + className);
                }
                return super.resolveClass(desc);
            }
        }) {
            Object obj = ois.readObject();
            System.out.println("安全反序列化: " + obj);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 实际应用场景

```java
import java.io.*;
import java.util.HashMap;
import java.util.Map;

public class PracticalExample {
    // 保存应用配置到文件
    public static void saveConfig(Map<String, Object> config, String filename) {
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(filename))) {
            oos.writeObject(config);
            System.out.println("配置保存成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    // 从文件加载应用配置
    @SuppressWarnings("unchecked")
    public static Map<String, Object> loadConfig(String filename) {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(filename))) {
            return (Map<String, Object>) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            System.out.println("加载配置失败，使用默认配置");
            return new HashMap<>();
        }
    }
    
    public static void main(String[] args) {
        // 模拟应用配置
        Map<String, Object> config = new HashMap<>();
        config.put("theme", "dark");
        config.put("language", "zh-CN");
        config.put("autoSave", true);
        config.put("timeout", 300);
        
        // 保存配置
        saveConfig(config, "app.config");
        
        // 加载配置
        Map<String, Object> loadedConfig = loadConfig("app.config");
        System.out.println("加载的配置: " + loadedConfig);
    }
}
```

