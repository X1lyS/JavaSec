# 泛型

**泛型的本质就是通过类型参数化（Type Parameters）定义一个代码模板**，让同一套逻辑可以适配多种数据类型，从而避免重复编写类似的代码。

## 理解泛型

假设我们需要一个数据处理类，他的逻辑是可以存储、读写、处理数据格式。如果我们需要处理String类型的数据，那么就写一个返回值为String的处理类

```java
package org.example;

public class  Processor {
    private String data;

    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    public String processData(String data) {
        //省略数据处理逻辑
        data = data;
        return data;
    }
}
```

但是现在我们增加了需求，我们不仅仅要处理String类型的数据，还需要处理int，那我们就需要再写一个专门处理int类型的处理类

```java
package org.example;

public class  Processor {
    private int data;

    public int getData() {
        return data;
    }
    public void setData(int data) {
        this.data = data;
    }

    public int processData(int data) {
        //省略数据处理逻辑
        data=data;
        return data;
    }
}
```

现在看来还不算麻烦，但是如果后面需要处理的数据类型越来越多，我们再去机械的定义新的数据处理类会很臃肿，也不便于维护，此时我们可以用泛型来定义一个模板就能很好的解决问题。

```java
package org.example;

public class  Processor<T> {
    private T data;

    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }

    public <T> T processData(T data) {
        if (data instanceof String) {
            return (T) ("处理字符串: " + ((String) data).toUpperCase());
        } else if (data instanceof Integer) {
            return (T) (Integer) (((Integer) data) * 2);
        } else if (data instanceof Boolean) {
            return (T) (Boolean) (!((Boolean) data));
        }
        return data; // 默认返回原数据
    }
}

```

```java
package org.example;

public class Main {
    public static void main(String[] args) {
        String datastring="hello word";
        int dataint=123;
        Processor<String> processorstring = new Processor<>();
        System.out.println(processorstring.processData(datastring));


        Processor<Integer> processorint = new Processor<>();
        System.out.println(processorint.processData(dataint));
    }
}
```

这就是泛型

##  泛型方法

这样定义泛型方法`public static <E> void method(E xx)`

```java
public class GenericMethodDemo {
    
    // 泛型方法：打印数组元素
    public static <E> void printArray(E[] inputArray) {
        for (E element : inputArray) {
            System.out.printf("%s ", element);
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // 测试不同类型的数组
        Integer[] intArray = {1, 2, 3, 4, 5};
        Double[] doubleArray = {1.1, 2.2, 3.3, 4.4};
        String[] stringArray = {"Hello", "World", "Generics"};

        System.out.println("Integer array:");
        printArray(intArray);

        System.out.println("Double array:");
        printArray(doubleArray);

        System.out.println("String array:");
        printArray(stringArray);
    }
}
```

## 泛型接口

```java
// 泛型接口
interface Pair<K, V> {
    K getKey();
    V getValue();
}

// 实现泛型接口
class OrderedPair<K, V> implements Pair<K, V> {
    private K key;
    private V value;

    public OrderedPair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}

public class GenericInterfaceDemo {
    public static void main(String[] args) {
        Pair<String, Integer> p1 = new OrderedPair<>("Even", 8);
        System.out.println(p1.getKey() + ": " + p1.getValue());

        Pair<String, String> p2 = new OrderedPair<>("Hello", "World");
        System.out.println(p2.getKey() + " " + p2.getValue());
    }
}
```

